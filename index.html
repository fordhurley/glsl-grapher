<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>GLSL Grapher</title>

  <link rel="stylesheet" href="build/style.css">

  <script src="ace.min.js"></script>
  <script src="ace.mode-glsl.min.js"></script>

  <script src="three.min.js"></script>
  <script src="GraphMaterial2D.js"></script>
  <script src="Graph2D.js"></script>

  <script src="GraphControls.js"></script>
</head>
<body>

<header>
  <h1>GLSL Grapher</h1>
</header>

<section id="tool">
  <div class="graph">
    <canvas></canvas>
    <div class="x-labels">
      <input type="number" size="1" class="min"></input>
      <input type="text" size="1" class="name" value="x" readonly></input>
      <input type="number" size="1" class="max"></input>
    </div>
    <div class="y-labels">
      <input type="number" size="1" class="max"></input>
      <input type="text" size="1" class="name" value="y" readonly></input>
      <input type="number" size="1" class="min"></input>
    </div>
  </div>

  <div id="editor">float y(float x) {
  return sin(x) / x;
}</div>
</section>

<section id="about">
  <h2>What is this?</h2>
  <p>
    This is a visualization tool for GLSL functions, using WebGL.
  </p>

  <h2>Why?</h2>
  <p>
    When writing shader code, it can be hard to visualize the output of a given
    function. There are a million other graphing tools, but all require you to
    translate your shader code into another format. This allows you to graph the
    output of your <em>actual</em> shader code.
  </p>

  <h2>Can you show me an example?</h2>
  <p>
    I'm working on adding a few more. Some ideas:
    <ul>
      <li>Easing functions</li>
      <li>RGB &harr; HSV conversions</li>
      <li>Noise</li>
      <li>Smoothstep</li>
    </ul>
  </p>
</section>

<script>
  window.addEventListener("load", function() {
    var editor = ace.edit("editor");
    editor.getSession().setMode("ace/mode/glsl");

    var canvas = document.querySelector(".graph canvas");
    var style = window.getComputedStyle(canvas);
    var width = parseInt(style.width);
    var height = parseInt(style.height);

    var renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    renderer.setClearColor(0xf9f9f9);

    var scene = new THREE.Scene();

    var camera = new THREE.OrthographicCamera(width/-2, width/2, height/2, height/-2, 1, 100);
    camera.position.z = 50;

    function render() {
      renderer.render(scene, camera);
    }

    var graph = new Graph2D({
      shaderFunc: editor.getValue(),
      limits: new THREE.Box2(
        new THREE.Vector2(-2*Math.PI, -2),
        new THREE.Vector2(4*Math.PI, 4)
      ),
      color: 0x3483BE,
    });
    graph.scale.set(width, height, 1);
    scene.add(graph);

    editor.getSession().on("change", function(e) {
      graph.material.setShaderFunc(editor.getValue());
      render();
    });

    var controls = new GraphControls(graph, canvas);
    controls.attachListeners();

    var labels = {
      x: {
        min: document.querySelector(".graph .x-labels .min"),
        max: document.querySelector(".graph .x-labels .max"),
      },
      y: {
        min: document.querySelector(".graph .y-labels .min"),
        max: document.querySelector(".graph .y-labels .max"),
      },
    };

    function updateLimitsFromLabels() {
      var limits = graph.material.limits;
      limits.min.x = parseFloat(labels.x.min.value);
      limits.max.x = parseFloat(labels.x.max.value);
      limits.min.y = parseFloat(labels.y.min.value);
      limits.max.y = parseFloat(labels.y.max.value);
      graph.setLimits(limits);
      render();
    }

    [labels.x.min, labels.x.max, labels.y.min, labels.y.max].forEach(function(label) {
      label.addEventListener("blur", updateLimitsFromLabels);
      label.addEventListener("keyup", function(e) {
        if (e.which === 13) { label.blur() }
      });
    });

    function updateLabels(limits) {
      var step = limits.getSize().multiplyScalar(0.1);
      labels.x.min.value = limits.min.x.toPrecision(3);
      labels.x.min.step = step.x.toPrecision(2);
      labels.x.max.value = limits.max.x.toPrecision(3);
      labels.x.max.step = labels.x.min.step;
      labels.y.min.value = limits.min.y.toPrecision(3);
      labels.y.min.step = step.y.toPrecision(2);
      labels.y.max.value = limits.max.y.toPrecision(3);
      labels.y.max.step = labels.y.min.step;
    }

    graph.addEventListener("changed:limits", function(e) {
      updateLabels(e.limits);
      render();
    });

    window.addEventListener("resize", function(e) {
      canvas.style = "";
      var style = window.getComputedStyle(canvas);
      var width = parseInt(style.width);
      var height = parseInt(style.height);
      renderer.setSize(width, height);
      camera.left = -width/2;
      camera.right = width/2;
      camera.top = height/2;
      camera.bottom = -height/2;
      camera.updateProjectionMatrix();
      graph.scale.set(width, height, 1);
      render();
    });

    updateLabels(graph.material.limits);
    render();
  });
</script>

</body>
</html>
